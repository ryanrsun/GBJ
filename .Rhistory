}
Z_common_means
# Now we can calculate the variance
alt_mean_vec <- k_vec
alt_var_vec <- rep(NA, length(t_vec))
alt_var_vec[non_zero] <- calc_var_nonzero_mu(d=d, t=t_vec[non_zero], mu=Z_common_means[non_zero],
pairwise_cors=pairwise_cors)
# Now match moments for alternative
mu_alt <- rep(NA, length(t_vec))
rho_alt <- rep(NA, length(t_vec))
gamma_alt <- rep(NA, length(t_vec))
mu_alt[non_zero] <- alt_mean_vec[non_zero] / d
rho_alt[non_zero] <- (alt_var_vec[non_zero] - d*mu_alt[non_zero]*(1-mu_alt[non_zero])) /
(d*(d-1)*mu_alt[non_zero]*(1-mu_alt[non_zero]))
gamma_alt[non_zero] = rho_alt[non_zero] / (1-rho_alt[non_zero])
# Numerical issues may give us mu and gamma that don't respect the bounds.
# We need gamma >= max{ -mu/(d-1), -(1-mu)/(d-1) }
pq_mat_null <- matrix(data=NA, nrow=length(t_vec), ncol=2)
pq_mat_alt <- matrix(data=NA, nrow=length(t_vec), ncol=2)
pq_mat_null[non_zero, 1] <- -mu_null[non_zero] / (d-1)
pq_mat_null[non_zero, 2] <- -(1-mu_null[non_zero]) / (d-1)
gamma_check_null <- apply(pq_mat_null, 1, max)
pq_mat_alt[non_zero, 1] <- -mu_alt[non_zero] / (d-1)
pq_mat_alt[non_zero, 2] <- -(1-mu_alt[non_zero]) / (d-1)
gamma_check_alt <- apply(pq_mat_alt, 1, max)
# Recalibrate non_zero
non_zero <- which(gamma_null >= gamma_check_null &
gamma_alt >= gamma_check_alt)
if (length(non_zero)==0 ) {
(rep(0,length(t_vec)) - rep(offset, length(t_vec)) )
}
non_zero
gamma_null
gamma_alt
t_vec=7
# Ensure that the thresholds are sorted in descending order, largest first.
t_vec <- sort(abs(t_vec), decreasing=TRUE)
# If didn't pass in a kkk vector, create it now (assume passed in all test statistics)
if (is.null(k_vec)) {
k_vec <- 1:d
}
# Check for qualifying p-values under the null (the indicator part of the GBJ statistic)
# and also that we are only considering 'first half' p-values
p_values <- 1-pchisq(t_vec^2, df=1)
GBJ_indicator <- which( p_values < k_vec/d )
first_half <- which(k_vec <= ceiling(d/2))
non_zero <- intersect(GBJ_indicator, first_half)
non_zero
# If no indicies qualified, stop
if (length(non_zero) == 0) {
return (rep(0,length(t_vec)) - rep(offset, length(t_vec)) )
}
#################################
# Some indices passed
# Calculate mean and variance of S(t) under the null for non-zero t
mean_null <- rep(NA, length(t_vec))
sigsq_null <- rep(NA, length(t_vec))
mean_null[non_zero] <- 2*d*surv(t_vec[non_zero])
sigsq_null <- calc_var_nonzero_mu(d=d, t=t_vec, mu=rep(0,length(t_vec)), pairwise_cors=pairwise_cors)
# Now match moments for null (directly)
mu_null <- rep(NA, length(t_vec))
rho_null <- rep(NA, length(t_vec))
gamma_null <- rep(NA, length(t_vec))
mu_null[non_zero] <- mean_null[non_zero] / d
rho_null[non_zero] <- (sigsq_null[non_zero] - d*mu_null[non_zero]*(1-mu_null[non_zero])) /
(d*(d-1)*mu_null[non_zero]*(1-mu_null[non_zero]))
gamma_null[non_zero] = rho_null[non_zero] / (1-rho_null[non_zero])
mean_null
sigsq_null
################################
# Calculate variance of S(t) under the alternative for non-zero t (the mean is given by k_vec)
# First, for each t, need to find the fitted common mean of the underlying test statistics
Z_common_means <- rep(NA, length(t_vec))
for (iii in 1:length(t_vec)) {
if(iii %in% non_zero)
{
# First get us the mean of the Z stats under the alternative
Z_common_means[iii] <- uniroot(qnorm_mu, lower=0, upper=100, t=t_vec[iii], kkk=k_vec[iii], d=d)$root
}
}
# Now we can calculate the variance
alt_mean_vec <- k_vec
alt_var_vec <- rep(NA, length(t_vec))
alt_var_vec[non_zero] <- calc_var_nonzero_mu(d=d, t=t_vec[non_zero], mu=Z_common_means[non_zero],
pairwise_cors=pairwise_cors)
# Now match moments for alternative
mu_alt <- rep(NA, length(t_vec))
rho_alt <- rep(NA, length(t_vec))
gamma_alt <- rep(NA, length(t_vec))
mu_alt[non_zero] <- alt_mean_vec[non_zero] / d
rho_alt[non_zero] <- (alt_var_vec[non_zero] - d*mu_alt[non_zero]*(1-mu_alt[non_zero])) /
(d*(d-1)*mu_alt[non_zero]*(1-mu_alt[non_zero]))
gamma_alt[non_zero] = rho_alt[non_zero] / (1-rho_alt[non_zero])
# Numerical issues may give us mu and gamma that don't respect the bounds.
# We need gamma >= max{ -mu/(d-1), -(1-mu)/(d-1) }
pq_mat_null <- matrix(data=NA, nrow=length(t_vec), ncol=2)
pq_mat_alt <- matrix(data=NA, nrow=length(t_vec), ncol=2)
pq_mat_null[non_zero, 1] <- -mu_null[non_zero] / (d-1)
pq_mat_null[non_zero, 2] <- -(1-mu_null[non_zero]) / (d-1)
gamma_check_null <- apply(pq_mat_null, 1, max)
pq_mat_alt[non_zero, 1] <- -mu_alt[non_zero] / (d-1)
pq_mat_alt[non_zero, 2] <- -(1-mu_alt[non_zero]) / (d-1)
gamma_check_alt <- apply(pq_mat_alt, 1, max)
# Recalibrate non_zero
non_zero <- which(gamma_null >= gamma_check_null &
gamma_alt >= gamma_check_alt)
if (length(non_zero)==0 ) {
(rep(0,length(t_vec)) - rep(offset, length(t_vec)) )
}
non_zero
length(t_vec)
# Log-liklihood for null
null_loglik <- rep(0, length(t_vec))
null_param_mat <- cbind( k_vec[non_zero], mu_null[non_zero], gamma_null[non_zero])
null_loglik[non_zero] <- apply(null_param_mat, 1, ebb_loglik, d=d)
# Log-likelihood for alternative
alt_loglik <- rep(0, length(t_vec))
alt_param_mat <- cbind( k_vec[non_zero], mu_alt[non_zero], gamma_alt[non_zero])
alt_loglik[non_zero] <- apply(alt_param_mat, 1, ebb_loglik, d=d)
BB_GBJ_stats <- alt_loglik - null_loglik
BB_GBJ_stats
alt_loglik
gamma_null
gamma_check_null
gamma_alt
gamma_check_alt
setwd('/users/ryansun/desktop')
install.packages(repos=NULL, pkgs='GBJ_0.1.0.tar.gz', type='source')
test_stats
GBJ(test_stats, cor_mat)
library(GBJ)
GBJ(test_stats, cor_mat)
library(GBJ)
test_stats = abs(rnorm(10)) + 0.2
cor_mat=diag(nrow=10)
GBJ(test_stats, cor_mat)
pairwise_cors=NULL
param_list <- parse_input(test_stats=test_stats, cor_mat=cor_mat,
pairwise_cors=pairwise_cors)
t_vec <- param_list$t_vec
pairwise_cors <- param_list$pairwise_cors
d <- length(t_vec)
# Sometimes test stats are too big for R's precision
too_big <- which(t_vec > 8.2)
if (length(too_big) > 0) {t_vec[too_big] <- 8.2}
# Correct number of pairwise correlations?
if (length(pairwise_cors) != d*(d-1)/2) {
stop("Your pairwise correlation vector is of the wrong length!")
}
# Calculate the observed GBJ statistic
GBJ_stats <- GBJ_objective(t_vec=t_vec, d=d, pairwise_cors=pairwise_cors)
gbj <- max(GBJ_stats)
gbj
observed_gbj=gbj
setwd('/users/ryansun/desktop')
install.packages(repos=NULL, pkgs='GBJ_0.1.0.tar.gz', type='source')
library(GBJ)
observed_gbj=5.264387
d=10
pairwise_cors=rep(0,45)
GBJ_pvalue(observed_gbj,d,pairwise_cors)
library(devtools)
library(roxygen2)
document()
library(GBJ)
cancer_status <- c(rep(1,100), rep(0,100))
cancer_status
genotype_data <- matrix(data=rbinom(n=200*50, size=2, prob=0.3), nrow=200)
head(genotype_data)
age <- round( runif(n=200, min=30, max=80) )
gender <- rbinom(n=200, size=1, prob=0.5)
age
gender
null_mod <- glm(cancer_status~age+gender, family=binomial(link="logit"))
log_reg_stats <- calc_score_stats(null_model=null_mod, factor_matrix=genotype_data, link_function="logistic")
cor_Z <- log_reg_stats$cor_mat
score_stats = log_reg_stats$test_stats
GBJ(test_stats=score_stats, cor_mat=cor_Z)
GHC(test_stats=score_stats, cor_mat=cor_Z)
build()
setwd('/users/ryansun/downloads')
a = read.table('genetic_map_b37/genetic_map_chr1_combined_b37.txt')
library(data.table)
a = fread('genetic_map_b37/genetic_map_chr1_combined_b37.txt')
dim(a)
setwd('/users/ryansun/desktop/mexico')
b = fread('IDC-infsex_chr1.map')
dim(b)
head(b)
a
ell = which(b$V4 %in% a$position)
length(ell)
dim(b)
dim(a)
head(ell)
head(b)
head(a)
a[1:50,]
head(a)
dim(a)
dim(b)
a[1:50,]
head(b)
getwd()
setwd('/users/ryansun/downloads')
mapf = fread('1_1-1000000.info')
pedf = fread('1_1-1000000.ped')
dim(mapf)
dim(pedf)
mapf
pedf[1:10,1:10]
pedf[1:10,1:10, with=F]
head(pedf$V7)
pedf = read.table('1_1-1000000.ped')
dim(pedf)
install_github(‘ryanrsun/GBJ’, build_vignettes=TRUE)
install_github('ryanrsun/GBJ', build_vignettes=TRUE)
library(speedglm)
library(rje)
num_sims <- 10^3
num_cases1 <- 403
num_cases2 <- 439
num_cases3 <- 200
num_controls1 <- 1124
num_controls2 <- 602
num_controls3 <- 200
total_cases <- num_cases1 + num_cases2 + num_cases3
total_controls <- num_controls1 + num_controls2 + num_controls3
# Found a stat that ARDS prevalence is ~10% of all ICU admissions
beta_0 <- -2.2
beta_G_vec <- log(seq(from=1.1, to=2.2, by=0.1))
# Number of total subjects we have to generate to get enough cases and controls
n <- round(total_cases * 5 / expit(beta_0), digits=0)
# G has MAF between 0.2-0.3
mu_G <- 0.25
# G has MAF between 0.2-0.3
mu_G <- 0.25
# Run simulation for each value of beta_G
ARDS_gwas <- matrix(data=NA, nrow=num_sims, ncol=4)
validation <- matrix(data=NA, nrow=num_sims, ncol=4)
start = proc.time()
for (i in 1:num_sims) {
# Generate 1 covariate and outcome
G <- rbinom(n=n, size=2, prob=mu_G)
eta <- beta_0 + G*beta_G
mu <- expit(eta)
Y <- rbinom(n=n, size=1, prob=mu)
# If not enough cases/controls
if (sum(Y) < total_cases | sum(Y) > (n-total_controls)) {next}
# Pick out cases and controls for each cohort
all_cases <- which(Y==1)
all_controls <- which(Y==0)
disc_rows <- c(all_cases[1:num_cases1], all_controls[1:num_controls1])
v1_rows <- c(all_cases[(num_cases1+1):(num_cases1+num_cases2)],
all_controls[(num_controls1+1):(num_controls1+num_controls2)])
v2_rows <- c(all_cases[(num_cases1+num_cases2+1):(num_cases1+num_cases2+num_cases3)],
all_controls[(num_controls1+num_controls2+1):(num_controls1+num_controls2+num_controls3)])
disc_design <- cbind(1, G[disc_rows])
disc_Y <- Y[disc_rows]
v1_design <- cbind(1, G[v1_rows])
v1_Y <- Y[v1_rows]
v2_design <- cbind(1, G[v2_rows])
v2_Y <- Y[v2_rows]
mod_disc <- speedglm.wfit(y=disc_Y, X=disc_design, family=binomial(link='logit'))
mod_v1 <- speedglm.wfit(y=v1_Y, X=v1_design, family=binomial(link='logit'))
mod_v2 <- speedglm.wfit(y=v2_Y, X=v2_design, family=binomial(link='logit'))
fitted_disc <- as.numeric(expit(disc_design %*% mod_disc$coefficients))
bread_disc <- solve( crossprod( disc_design * fitted_disc*(1-fitted_disc), disc_design ) )
fitted_v1 <- as.numeric(expit(v1_design %*% mod_v1$coefficients))
bread_v1 <- solve( crossprod( v1_design * fitted_v1*(1-fitted_v1), v1_design ) )
fitted_v2 <- as.numeric(expit(v2_design %*% mod_v2$coefficients))
bread_v2 <- solve( crossprod( v2_design * fitted_v2*(1-fitted_v2), v2_design ) )
disc_stat <- mod_disc$coefficients[2] / sqrt(bread_disc[2,2])
v1_stat <- mod_v1$coefficients[2] / sqrt(bread_v1[2,2])
v2_stat <- mod_v2$coefficients[2] / sqrt(bread_v2[2,2])
# Record
record_row <- (beta_G_it-1) * num_sims + i
ARDS_gwas[record_row, 1] <- beta_G
ARDS_gwas[record_row, 2] <- 1-pchisq(disc_stat^2, df=1)
ARDS_gwas[record_row, 3] <- 1-pchisq(v1_stat^2, df=1)
ARDS_gwas[record_row, 4] <- 1-pchisq(v2_stat^2, df=1)
if (i %% 1000 == 0) {cat(i)}
}
end = proc.time()
end - start
beta_G <- beta_G_vec[beta_G_it]
beta_G_it = 1
start = proc.time()
for (i in 1:num_sims) {
# Generate 1 covariate and outcome
G <- rbinom(n=n, size=2, prob=mu_G)
eta <- beta_0 + G*beta_G
mu <- expit(eta)
Y <- rbinom(n=n, size=1, prob=mu)
# If not enough cases/controls
if (sum(Y) < total_cases | sum(Y) > (n-total_controls)) {next}
# Pick out cases and controls for each cohort
all_cases <- which(Y==1)
all_controls <- which(Y==0)
disc_rows <- c(all_cases[1:num_cases1], all_controls[1:num_controls1])
v1_rows <- c(all_cases[(num_cases1+1):(num_cases1+num_cases2)],
all_controls[(num_controls1+1):(num_controls1+num_controls2)])
v2_rows <- c(all_cases[(num_cases1+num_cases2+1):(num_cases1+num_cases2+num_cases3)],
all_controls[(num_controls1+num_controls2+1):(num_controls1+num_controls2+num_controls3)])
disc_design <- cbind(1, G[disc_rows])
disc_Y <- Y[disc_rows]
v1_design <- cbind(1, G[v1_rows])
v1_Y <- Y[v1_rows]
v2_design <- cbind(1, G[v2_rows])
v2_Y <- Y[v2_rows]
mod_disc <- speedglm.wfit(y=disc_Y, X=disc_design, family=binomial(link='logit'))
mod_v1 <- speedglm.wfit(y=v1_Y, X=v1_design, family=binomial(link='logit'))
mod_v2 <- speedglm.wfit(y=v2_Y, X=v2_design, family=binomial(link='logit'))
fitted_disc <- as.numeric(expit(disc_design %*% mod_disc$coefficients))
bread_disc <- solve( crossprod( disc_design * fitted_disc*(1-fitted_disc), disc_design ) )
fitted_v1 <- as.numeric(expit(v1_design %*% mod_v1$coefficients))
bread_v1 <- solve( crossprod( v1_design * fitted_v1*(1-fitted_v1), v1_design ) )
fitted_v2 <- as.numeric(expit(v2_design %*% mod_v2$coefficients))
bread_v2 <- solve( crossprod( v2_design * fitted_v2*(1-fitted_v2), v2_design ) )
disc_stat <- mod_disc$coefficients[2] / sqrt(bread_disc[2,2])
v1_stat <- mod_v1$coefficients[2] / sqrt(bread_v1[2,2])
v2_stat <- mod_v2$coefficients[2] / sqrt(bread_v2[2,2])
# Record
record_row <- (beta_G_it-1) * num_sims + i
ARDS_gwas[record_row, 1] <- beta_G
ARDS_gwas[record_row, 2] <- 1-pchisq(disc_stat^2, df=1)
ARDS_gwas[record_row, 3] <- 1-pchisq(v1_stat^2, df=1)
ARDS_gwas[record_row, 4] <- 1-pchisq(v2_stat^2, df=1)
if (i %% 1000 == 0) {cat(i)}
}
end = proc.time()
end - start
beta_G <- beta_G_vec[beta_G_it]
start = proc.time()
for (i in 1:num_sims) {
# Generate 1 covariate and outcome
G <- rbinom(n=n, size=2, prob=mu_G)
eta <- beta_0 + G*beta_G
mu <- expit(eta)
Y <- rbinom(n=n, size=1, prob=mu)
# If not enough cases/controls
if (sum(Y) < total_cases | sum(Y) > (n-total_controls)) {next}
# Pick out cases and controls for each cohort
all_cases <- which(Y==1)
all_controls <- which(Y==0)
disc_rows <- c(all_cases[1:num_cases1], all_controls[1:num_controls1])
v1_rows <- c(all_cases[(num_cases1+1):(num_cases1+num_cases2)],
all_controls[(num_controls1+1):(num_controls1+num_controls2)])
v2_rows <- c(all_cases[(num_cases1+num_cases2+1):(num_cases1+num_cases2+num_cases3)],
all_controls[(num_controls1+num_controls2+1):(num_controls1+num_controls2+num_controls3)])
disc_design <- cbind(1, G[disc_rows])
disc_Y <- Y[disc_rows]
v1_design <- cbind(1, G[v1_rows])
v1_Y <- Y[v1_rows]
v2_design <- cbind(1, G[v2_rows])
v2_Y <- Y[v2_rows]
mod_disc <- speedglm.wfit(y=disc_Y, X=disc_design, family=binomial(link='logit'))
mod_v1 <- speedglm.wfit(y=v1_Y, X=v1_design, family=binomial(link='logit'))
mod_v2 <- speedglm.wfit(y=v2_Y, X=v2_design, family=binomial(link='logit'))
fitted_disc <- as.numeric(expit(disc_design %*% mod_disc$coefficients))
bread_disc <- solve( crossprod( disc_design * fitted_disc*(1-fitted_disc), disc_design ) )
fitted_v1 <- as.numeric(expit(v1_design %*% mod_v1$coefficients))
bread_v1 <- solve( crossprod( v1_design * fitted_v1*(1-fitted_v1), v1_design ) )
fitted_v2 <- as.numeric(expit(v2_design %*% mod_v2$coefficients))
bread_v2 <- solve( crossprod( v2_design * fitted_v2*(1-fitted_v2), v2_design ) )
disc_stat <- mod_disc$coefficients[2] / sqrt(bread_disc[2,2])
v1_stat <- mod_v1$coefficients[2] / sqrt(bread_v1[2,2])
v2_stat <- mod_v2$coefficients[2] / sqrt(bread_v2[2,2])
# Record
record_row <- (beta_G_it-1) * num_sims + i
ARDS_gwas[record_row, 1] <- beta_G
ARDS_gwas[record_row, 2] <- 1-pchisq(disc_stat^2, df=1)
ARDS_gwas[record_row, 3] <- 1-pchisq(v1_stat^2, df=1)
ARDS_gwas[record_row, 4] <- 1-pchisq(v2_stat^2, df=1)
if (i %% 1000 == 0) {cat(i)}
}
end = proc.time()
end - start
head(ARDS_gwas)
start = proc.time()
for (i in 1:num_sims) {
# Generate 1 covariate and outcome
G <- rbinom(n=n, size=2, prob=mu_G)
eta <- beta_0 + G*beta_G
mu <- expit(eta)
Y <- rbinom(n=n, size=1, prob=mu)
# If not enough cases/controls
if (sum(Y) < total_cases | sum(Y) > (n-total_controls)) {next}
# Pick out cases and controls for each cohort
all_cases <- which(Y==1)
all_controls <- which(Y==0)
disc_rows <- c(all_cases[1:num_cases1], all_controls[1:num_controls1])
v1_rows <- c(all_cases[(num_cases1+1):(num_cases1+num_cases2)],
all_controls[(num_controls1+1):(num_controls1+num_controls2)])
v2_rows <- c(all_cases[(num_cases1+num_cases2+1):(num_cases1+num_cases2+num_cases3)],
all_controls[(num_controls1+num_controls2+1):(num_controls1+num_controls2+num_controls3)])
disc_G <- G[disc_rows]
v1_G <- G[v1_rows]
v2_G <- G[v2_rows]
disc_mod <- glm(disc_Y ~ disc_G, family=binomial(link='logit'))
v1_mod <- glm(v1_Y ~ v1_G, family=binomial(link='logit'))
v2_mod <- glm(v2_Y ~ v2_G, family=binomial(link='logit'))
record_row <- (beta_G_it-1) * num_sims + i
validation[record_row, 1] <- beta_G
validation[record_row, 2] <- summary(disc_mod)$coefficients[2,4]
validation[record_row, 3] <- summary(v1_mod)$coefficients[2,4]
validation[record_row, 4] <- summary(v2_mod)$coefficients[2,4]
if (i %% 1000 == 0) {cat(i)}
}
end = proc.time()
end - start
start = proc.time()
for (i in 1:num_sims) {
# Generate 1 covariate and outcome
G <- rbinom(n=n, size=2, prob=mu_G)
eta <- beta_0 + G*beta_G
mu <- expit(eta)
Y <- rbinom(n=n, size=1, prob=mu)
# If not enough cases/controls
if (sum(Y) < total_cases | sum(Y) > (n-total_controls)) {next}
# Pick out cases and controls for each cohort
all_cases <- which(Y==1)
all_controls <- which(Y==0)
disc_rows <- c(all_cases[1:num_cases1], all_controls[1:num_controls1])
v1_rows <- c(all_cases[(num_cases1+1):(num_cases1+num_cases2)],
all_controls[(num_controls1+1):(num_controls1+num_controls2)])
v2_rows <- c(all_cases[(num_cases1+num_cases2+1):(num_cases1+num_cases2+num_cases3)],
all_controls[(num_controls1+num_controls2+1):(num_controls1+num_controls2+num_controls3)])
disc_design <- cbind(1, G[disc_rows])
disc_Y <- Y[disc_rows]
v1_design <- cbind(1, G[v1_rows])
v1_Y <- Y[v1_rows]
v2_design <- cbind(1, G[v2_rows])
v2_Y <- Y[v2_rows]
mod_disc <- speedglm.wfit(y=disc_Y, X=disc_design, family=binomial(link='logit'))
mod_v1 <- speedglm.wfit(y=v1_Y, X=v1_design, family=binomial(link='logit'))
mod_v2 <- speedglm.wfit(y=v2_Y, X=v2_design, family=binomial(link='logit'))
fitted_disc <- as.numeric(expit(disc_design %*% mod_disc$coefficients))
bread_disc <- solve( crossprod( disc_design * fitted_disc*(1-fitted_disc), disc_design ) )
fitted_v1 <- as.numeric(expit(v1_design %*% mod_v1$coefficients))
bread_v1 <- solve( crossprod( v1_design * fitted_v1*(1-fitted_v1), v1_design ) )
fitted_v2 <- as.numeric(expit(v2_design %*% mod_v2$coefficients))
bread_v2 <- solve( crossprod( v2_design * fitted_v2*(1-fitted_v2), v2_design ) )
disc_stat <- mod_disc$coefficients[2] / sqrt(bread_disc[2,2])
v1_stat <- mod_v1$coefficients[2] / sqrt(bread_v1[2,2])
v2_stat <- mod_v2$coefficients[2] / sqrt(bread_v2[2,2])
# Record
record_row <- (beta_G_it-1) * num_sims + i
ARDS_gwas[record_row, 1] <- beta_G
ARDS_gwas[record_row, 2] <- 1-pchisq(disc_stat^2, df=1)
ARDS_gwas[record_row, 3] <- 1-pchisq(v1_stat^2, df=1)
ARDS_gwas[record_row, 4] <- 1-pchisq(v2_stat^2, df=1)
disc_G <- G[disc_rows]
v1_G <- G[v1_rows]
v2_G <- G[v2_rows]
disc_mod <- glm(disc_Y ~ disc_G, family=binomial(link='logit'))
v1_mod <- glm(v1_Y ~ v1_G, family=binomial(link='logit'))
v2_mod <- glm(v2_Y ~ v2_G, family=binomial(link='logit'))
record_row <- (beta_G_it-1) * num_sims + i
validation[record_row, 1] <- beta_G
validation[record_row, 2] <- summary(disc_mod)$coefficients[2,4]
validation[record_row, 3] <- summary(v1_mod)$coefficients[2,4]
validation[record_row, 4] <- summary(v2_mod)$coefficients[2,4]
if (i %% 1000 == 0) {cat(i)}
}
end = proc.time()
end - start
start = proc.time()
for (i in 1:num_sims) {
# Generate 1 covariate and outcome
G <- rbinom(n=n, size=2, prob=mu_G)
eta <- beta_0 + G*beta_G
mu <- expit(eta)
Y <- rbinom(n=n, size=1, prob=mu)
# If not enough cases/controls
if (sum(Y) < total_cases | sum(Y) > (n-total_controls)) {next}
# Pick out cases and controls for each cohort
all_cases <- which(Y==1)
all_controls <- which(Y==0)
disc_rows <- c(all_cases[1:num_cases1], all_controls[1:num_controls1])
v1_rows <- c(all_cases[(num_cases1+1):(num_cases1+num_cases2)],
all_controls[(num_controls1+1):(num_controls1+num_controls2)])
v2_rows <- c(all_cases[(num_cases1+num_cases2+1):(num_cases1+num_cases2+num_cases3)],
all_controls[(num_controls1+num_controls2+1):(num_controls1+num_controls2+num_controls3)])
if (i %% 1000 == 0) {cat(i)}
}
end = proc.time()
end - start
n
# Number of total subjects we have to generate to get enough cases and controls
n <- round(total_cases * 2 / expit(beta_0), digits=0)
start = proc.time()
for (i in 1:num_sims) {
# Generate 1 covariate and outcome
G <- rbinom(n=n, size=2, prob=mu_G)
eta <- beta_0 + G*beta_G
mu <- expit(eta)
Y <- rbinom(n=n, size=1, prob=mu)
# If not enough cases/controls
if (sum(Y) < total_cases | sum(Y) > (n-total_controls)) {next}
# Pick out cases and controls for each cohort
all_cases <- which(Y==1)
all_controls <- which(Y==0)
disc_rows <- c(all_cases[1:num_cases1], all_controls[1:num_controls1])
v1_rows <- c(all_cases[(num_cases1+1):(num_cases1+num_cases2)],
all_controls[(num_controls1+1):(num_controls1+num_controls2)])
v2_rows <- c(all_cases[(num_cases1+num_cases2+1):(num_cases1+num_cases2+num_cases3)],
all_controls[(num_controls1+num_controls2+1):(num_controls1+num_controls2+num_controls3)])
if (i %% 1000 == 0) {cat(i)}
}
end = proc.time()
end - start
